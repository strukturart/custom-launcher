import EventEmitter from "wolfy87-eventemitter"
/**
 * @file
 * File picker and finder for device storages on Firefox OS devices
 *
 * This library provides an easy-to-use asynchronous interface for other Firefox OS apps to search for files
 * on Firefox OS devices. The library is based on an event-based architecture, letting developers build
 * beautiful asynchronous API for their apps.
 *
 * The `Finder` library is best used by developers looking to pick a file from the `sdcard` for their apps.
 *
 * This library depends on [EventEmitter](https://github.com/Wolfy87/EventEmitter) by Wolfy87, included with the
 * package.
 *
 * @version 1.1.3
 * @license The MIT License (MIT)
 * @author Applait Technologies LLP
 * @copyright Copyright (c) 2014 Applait Technologies LLP
 */
export const Finder = function (options) { this.options = options || {}, this.type = this.options.type || "sdcard", this.hidden = this.options.hidden || !1, this.casesensitive = this.options.caseSensitive || !1, this.minsearchlength = this.options.minSearchLength && "number" == typeof this.options.minSearchLength ? options.minSearchLength : 3, this.debugmode = this.options.debugMode ? !0 : !1, this.storages = navigator.getDeviceStorages && navigator.getDeviceStorages(this.type), this.searchcompletecount = 0, this.filematchcount = 0, this.searchkey = "" }
Finder.prototype = new EventEmitter
Finder.prototype.checkhidden = function (fullpath) { return "/" === fullpath[fullpath.indexOf(".") - 1] && this.hidden !== !0 ? !1 : !0 }
Finder.prototype.search = function (needle) { var self = this; return self.reset(), self.searchkey = self.casesensitive ? needle.trim() : needle.trim().toLowerCase(), self.searchkey.length < self.minsearchlength ? (self.log("searchCancelled", ["Search string should be at least " + self.minsearchlength + " characters"]), self.emitEvent("searchCancelled", ["Search string should be at least " + self.minsearchlength + " characters"]), null) : self.storagecount() < 1 ? (self.log("empty", [self.searchkey]), self.emitEvent("empty", [self.searchkey]), null) : (self.log("searchBegin", [self.searchkey]), self.emitEvent("searchBegin", [self.searchkey]), void self.storages.forEach(function (storage) { var cursor = storage.enumerate(); self.log("storageSearchBegin", [storage.storageName, self.searchkey]), self.emitEvent("storageSearchBegin", [storage.storageName, self.searchkey]), cursor.onsuccess = function () { if (this.result) { var file = this.result, fileinfo = self.splitname(file.name); self.matchname(fileinfo.name, file.name) && (self.filematchcount++ , self.log("fileFound", [file, fileinfo, storage.storageName]), self.emitEvent("fileFound", [file, fileinfo, storage.storageName])), this.done ? (self.searchcompletecount++ , self.log("storageSearchComplete", [storage.storageName, self.searchkey]), self.emitEvent("storageSearchComplete", [storage.storageName, self.searchkey])) : this.continue() } else self.searchcompletecount++ , self.log("storageSearchComplete", [storage.storageName, self.searchkey]), self.emitEvent("storageSearchComplete", [storage.storageName, self.searchkey]); self.searchcompletecount === self.storagecount() && (self.log("searchComplete", [self.searchkey, self.filematchcount]), self.emitEvent("searchComplete", [self.searchkey, self.filematchcount])) }, cursor.onerror = function () { self.log("error", ["Error accessing device storage '" + storage.storageName + "'", this.error]), self.emitEvent("error", ["Error accessing device storage '" + storage.storageName + "'", this.error]) } })) }
Finder.prototype.splitname = function (filename) { return filename = filename.split(/[\\/]/), { name: filename.pop(), path: filename.join("/") } }
Finder.prototype.storagecount = function () { return this.storages && this.storages.length ? this.storages.length : 0 }
Finder.prototype.reset = function () { this.filematchcount = 0, this.searchcompletecount = 0, this.searchkey = "" }
Finder.prototype.log = function (message, args) { this.debugmode && console.log(message, args) }
Finder.prototype.matchname = function (name, fullpath) { return name = this.casesensitive ? name.trim() : name.trim().toLowerCase(), name.indexOf(this.searchkey) > -1 && this.checkhidden(fullpath) };
